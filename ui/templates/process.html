<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Process Documents</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <div class="container mt-4">
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="/">Home</a></li>
                <li class="breadcrumb-item active" aria-current="page">Process Documents</li>
            </ol>
        </nav>
        
        <h1 class="mb-4">Process Documents</h1>
        
        <div class="card mb-4">
            <div class="card-header bg-primary text-white">
                Processing Configuration
            </div>
            <div class="card-body">
                <form id="process-form">
                    <div class="card mb-3">
                        <div class="card-header bg-light">Chunking Settings</div>
                        <div class="card-body">
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="enable-chunking" checked>
                                <label class="form-check-label" for="enable-chunking">Enable Document Chunking</label>
                            </div>
                            
                            <div id="chunking-settings">
                                <div class="row mb-3">
                                    <div class="col-md-4">
                                        <label for="chunk-size" class="form-label">Maximum Chunk Size (characters)</label>
                                        <input type="number" class="form-control" id="chunk-size" value="250" min="100">
                                        <div class="form-text">Maximum size of each document chunk</div>
                                    </div>
                                    
                                    <div class="col-md-4">
                                        <label for="min-size" class="form-label">Minimum Chunk Size (characters)</label>
                                        <input type="number" class="form-control" id="min-size" value="100" min="50">
                                        <div class="form-text">Minimum size before creating a new chunk</div>
                                    </div>
                                    
                                    <div class="col-md-4">
                                        <label for="overlap" class="form-label">Chunk Overlap (characters)</label>
                                        <input type="number" class="form-control" id="overlap" value="75" min="0">
                                        <div class="form-text">Overlap between adjacent chunks</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card mb-3">
                        <div class="card-header bg-light">Semantic Enrichment</div>
                        <div class="card-body">
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="enable-enrichment" checked>
                                <label class="form-check-label" for="enable-enrichment">Enable Semantic Enrichment</label>
                            </div>
                            <p class="text-muted small mb-0">
                                When enabled, Ollama will generate additional content for each chunk, including key concepts, synonyms, 
                                and related topics to enhance retrieval quality. This makes documents easier to find with natural language queries.
                            </p>
                        </div>
                    </div>
                    
                    <button type="submit" class="btn btn-primary" id="process-button">
                        <span id="process-spinner" class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                        Process Documents
                    </button>
                </form>
            </div>
        </div>
        
        <!-- Job Status Card - Initially Hidden -->
        <div class="card mb-4 d-none" id="job-status-card">
            <div class="card-header bg-info text-white d-flex justify-content-between align-items-center">
                <div>
                    <i class="bi bi-clock-history"></i> Processing Job Status
                </div>
                <div>
                    <span class="badge bg-light text-dark job-id-badge" id="job-id-display"></span>
                </div>
            </div>
            <div class="card-body">
                <div class="d-flex justify-content-between mb-2">
                    <div>
                        <span class="badge" id="job-status-badge">Queued</span>
                    </div>
                    <div>
                        <small>Started: <span id="job-started-time">Just now</span></small>
                    </div>
                </div>
                
                <div class="progress mb-3" style="height: 25px;">
                    <div id="job-progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" 
                         role="progressbar" style="width: 0%;" 
                         aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                </div>
                
                <div class="job-stats mb-3">
                    <div class="row text-center">
                        <div class="col-md-3">
                            <div class="stat-item">
                                <div class="stat-value" id="stat-files">0</div>
                                <div class="stat-label">Files</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="stat-item">
                                <div class="stat-value" id="stat-processed">0</div>
                                <div class="stat-label">Processed</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="stat-item">
                                <div class="stat-value text-success" id="stat-success">0</div>
                                <div class="stat-label">Success</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="stat-item">
                                <div class="stat-value text-danger" id="stat-failed">0</div>
                                <div class="stat-label">Failed</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="d-flex justify-content-end">
                    <button class="btn btn-sm btn-outline-secondary me-2" id="stop-polling-btn">
                        <i class="bi bi-pause-circle"></i> Stop Updates
                    </button>
                    <button class="btn btn-sm btn-outline-primary d-none" id="resume-polling-btn">
                        <i class="bi bi-play-circle"></i> Resume Updates
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Result Card - Shows Final Results -->
        <div class="card mb-4 d-none" id="result-card">
            <div class="card-header bg-success text-white">
                <i class="bi bi-check-circle"></i> Processing Results
            </div>
            <div class="card-body" id="result-content">
            </div>
        </div>
        
        <!-- All Jobs Card -->
        <div class="card mb-4 d-none" id="all-jobs-card">
            <div class="card-header bg-secondary text-white d-flex justify-content-between align-items-center">
                <div>
                    <i class="bi bi-list-check"></i> Recent Jobs
                </div>
                <div>
                    <button class="btn btn-sm btn-light" id="refresh-jobs-btn">
                        <i class="bi bi-arrow-clockwise"></i> Refresh
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Job ID</th>
                                <th>Status</th>
                                <th>Progress</th>
                                <th>Files</th>
                                <th>Success</th>
                                <th>Failed</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="jobs-table-body">
                            <!-- Jobs will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Elements - Form and Settings
            const enableChunkingSwitch = document.getElementById('enable-chunking');
            const chunkingSettings = document.getElementById('chunking-settings');
            const processForm = document.getElementById('process-form');
            const processButton = document.getElementById('process-button');
            const processSpinner = document.getElementById('process-spinner');
            
            // Elements - Cards
            const jobStatusCard = document.getElementById('job-status-card');
            const resultCard = document.getElementById('result-card');
            const resultContent = document.getElementById('result-content');
            const allJobsCard = document.getElementById('all-jobs-card');
            
            // Elements - Job Status
            const jobIdDisplay = document.getElementById('job-id-display');
            const jobStatusBadge = document.getElementById('job-status-badge');
            const jobProgressBar = document.getElementById('job-progress-bar');
            const jobStartedTime = document.getElementById('job-started-time');
            
            // Elements - Job Stats
            const statFiles = document.getElementById('stat-files');
            const statProcessed = document.getElementById('stat-processed');
            const statSuccess = document.getElementById('stat-success');
            const statFailed = document.getElementById('stat-failed');
            
            // Elements - Polling Controls
            const stopPollingBtn = document.getElementById('stop-polling-btn');
            const resumePollingBtn = document.getElementById('resume-polling-btn');
            const refreshJobsBtn = document.getElementById('refresh-jobs-btn');
            const jobsTableBody = document.getElementById('jobs-table-body');
            
            // Polling variables
            let currentJobId = null;
            let pollingInterval = null;
            let isPolling = false;
            let jobStartTime = null;
            
            // Toggle chunking settings visibility
            enableChunkingSwitch.addEventListener('change', () => {
                if (enableChunkingSwitch.checked) {
                    chunkingSettings.classList.remove('d-none');
                } else {
                    chunkingSettings.classList.add('d-none');
                }
            });
            
            // Format time elapsed
            function formatTimeElapsed(startTime) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                if (elapsed < 60) {
                    return `${elapsed} seconds ago`;
                } else if (elapsed < 3600) {
                    return `${Math.floor(elapsed / 60)} minutes ago`;
                } else {
                    return `${Math.floor(elapsed / 3600)} hours ago`;
                }
            }
            
            // Update job status display
            function updateJobStatusDisplay(jobData) {
                // Update progress bar
                const progress = jobData.progress || 0;
                jobProgressBar.style.width = `${progress}%`;
                jobProgressBar.setAttribute('aria-valuenow', progress);
                jobProgressBar.textContent = `${progress}%`;
                
                // Update status badge
                let statusClass = 'bg-secondary';
                switch(jobData.status) {
                    case 'queued':
                        statusClass = 'bg-secondary';
                        break;
                    case 'processing':
                        statusClass = 'bg-info';
                        break;
                    case 'completed':
                        statusClass = 'bg-success';
                        break;
                    case 'failed':
                        statusClass = 'bg-danger';
                        break;
                }
                jobStatusBadge.className = `badge ${statusClass}`;
                jobStatusBadge.textContent = jobData.status.charAt(0).toUpperCase() + jobData.status.slice(1);
                
                // Update stats
                statFiles.textContent = jobData.total_files || 0;
                statProcessed.textContent = jobData.processed_files || 0;
                statSuccess.textContent = jobData.successful_chunks || 0;
                statFailed.textContent = jobData.failed_chunks || 0;
                
                // Update time elapsed
                if (jobStartTime) {
                    jobStartedTime.textContent = formatTimeElapsed(jobStartTime);
                }
                
                // Handle job completion
                if (jobData.status === 'completed' || jobData.status === 'failed') {
                    // Stop polling
                    stopPolling();
                    
                    // Show the result card with final results
                    showResults(jobData);
                }
            }
            
            // Poll for job status
            async function pollJobStatus() {
                if (!currentJobId || !isPolling) return;
                
                try {
                    const response = await fetch(`/job/${currentJobId}`);
                    const jobData = await response.json();
                    
                    // Update the UI with job status
                    updateJobStatusDisplay(jobData);
                    
                } catch (error) {
                    console.error('Error polling job status:', error);
                }
            }
            
            // Start polling
            function startPolling(jobId) {
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                }
                
                currentJobId = jobId;
                isPolling = true;
                jobStartTime = Date.now();
                
                // Initial poll
                pollJobStatus();
                
                // Set up polling interval (every 2 seconds)
                pollingInterval = setInterval(pollJobStatus, 2000);
                
                // Show polling controls
                stopPollingBtn.classList.remove('d-none');
                resumePollingBtn.classList.add('d-none');
            }
            
            // Stop polling
            function stopPolling() {
                isPolling = false;
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                }
                
                // Update UI controls
                stopPollingBtn.classList.add('d-none');
                resumePollingBtn.classList.remove('d-none');
            }
            
            // Resume polling
            function resumePolling() {
                if (currentJobId) {
                    isPolling = true;
                    pollJobStatus();
                    pollingInterval = setInterval(pollJobStatus, 2000);
                    
                    // Update UI controls
                    stopPollingBtn.classList.remove('d-none');
                    resumePollingBtn.classList.add('d-none');
                }
            }
            
            // Show results in the result card
            function showResults(jobData) {
                if (!jobData.result) return;
                
                resultCard.classList.remove('d-none');
                const result = jobData.result;
                
                let resultHtml = '';
                
                // Add message
                if (result.message) {
                    const alertClass = result.failed_chunks > 0 ? 'alert-warning' : 'alert-success';
                    resultHtml += `<div class="alert ${alertClass}">${result.message}</div>`;
                }
                
                // Add statistics
                resultHtml += '<div class="row mt-3">';
                resultHtml += `<div class="col-md-3"><strong>Source Files:</strong> ${result.source_files || 0}</div>`;
                resultHtml += `<div class="col-md-3"><strong>Total Chunks:</strong> ${result.total_chunks || 0}</div>`;
                resultHtml += `<div class="col-md-3"><strong>Successful:</strong> ${result.successful_chunks || 0}</div>`;
                resultHtml += `<div class="col-md-3"><strong>Failed:</strong> ${result.failed_chunks || 0}</div>`;
                resultHtml += '</div>';
                
                // Add semantic enrichment status if available
                if (result.semantic_enrichment) {
                    const enrichment = result.semantic_enrichment;
                    const statusColor = enrichment.enabled ? 'success' : 'secondary';
                    resultHtml += `
                        <div class="mt-3">
                            <h5>Semantic Enrichment</h5>
                            <div class="badge bg-${statusColor} mb-2">${enrichment.enabled ? 'Enabled' : 'Disabled'}</div>
                            <p class="mb-0">Chunks processed with enrichment: ${enrichment.chunks_processed}</p>
                        </div>
                    `;
                }
                
                // Add term extraction status if available
                if (result.term_extraction) {
                    const termExtraction = result.term_extraction;
                    const statusColor = termExtraction.terms_updated ? 'success' : 'warning';
                    resultHtml += `
                        <div class="mt-3">
                            <h5>Domain Term Extraction</h5>
                            <div class="badge bg-${statusColor} mb-2">${termExtraction.terms_updated ? 'Updated' : 'Failed'}</div>
                            ${termExtraction.terms_updated ? 
                                `<p class="mb-0">Terms updated: ${termExtraction.previous_term_count} → ${termExtraction.new_term_count}</p>` : 
                                `<p class="mb-0 text-danger">Error: ${termExtraction.error}</p>`
                            }
                        </div>
                    `;
                }
                
                // Add failed items if any
                if (result.failed_chunks > 0 && result.failed_items) {
                    resultHtml += '<div class="mt-3">';
                    resultHtml += '<h5>Failed Items:</h5>';
                    resultHtml += '<div class="accordion" id="failedItemsAccordion">';
                    resultHtml += `
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#failedItemsContent">
                                    ${result.failed_items.length} Failed Items
                                </button>
                            </h2>
                            <div id="failedItemsContent" class="accordion-collapse collapse">
                                <div class="accordion-body">
                                    <ul class="small text-danger">
                    `;
                    
                    result.failed_items.forEach(item => {
                        resultHtml += `<li>${item}</li>`;
                    });
                    
                    resultHtml += `
                                    </ul>
                                </div>
                            </div>
                        </div>
                    `;
                    resultHtml += '</div>';
                    resultHtml += '</div>';
                }
                
                resultContent.innerHTML = resultHtml;
            }
            
            // Load and display all jobs
            async function loadAllJobs() {
                try {
                    const response = await fetch('/jobs');
                    const data = await response.json();
                    
                    if (data.total_jobs > 0) {
                        // Show the all jobs card
                        allJobsCard.classList.remove('d-none');
                        
                        // Clear existing rows
                        jobsTableBody.innerHTML = '';
                        
                        // Sort jobs by newest first (assuming job_id has some timestamp component)
                        const sortedJobs = Object.entries(data.jobs).sort((a, b) => b[0].localeCompare(a[0]));
                        
                        // Add rows for each job
                        sortedJobs.forEach(([jobId, jobData]) => {
                            const row = document.createElement('tr');
                            
                            // Status badge
                            let statusClass = 'bg-secondary';
                            switch(jobData.status) {
                                case 'queued':
                                    statusClass = 'bg-secondary';
                                    break;
                                case 'processing':
                                    statusClass = 'bg-info';
                                    break;
                                case 'completed':
                                    statusClass = 'bg-success';
                                    break;
                                case 'failed':
                                    statusClass = 'bg-danger';
                                    break;
                            }
                            
                            row.innerHTML = `
                                <td><small class="text-muted">${jobId.substring(0, 8)}...</small></td>
                                <td><span class="badge ${statusClass}">${jobData.status}</span></td>
                                <td>
                                    <div class="progress" style="height: 15px;">
                                        <div class="progress-bar ${statusClass}" style="width: ${jobData.progress}%;" 
                                             aria-valuenow="${jobData.progress}" aria-valuemin="0" aria-valuemax="100">
                                             ${jobData.progress}%
                                        </div>
                                    </div>
                                </td>
                                <td>${jobData.total_files || 0}</td>
                                <td>${jobData.successful_chunks || 0}</td>
                                <td>${jobData.failed_chunks || 0}</td>
                                <td>
                                    <button class="btn btn-sm btn-outline-primary view-job-btn" data-job-id="${jobId}">
                                        <i class="bi bi-eye"></i>
                                    </button>
                                </td>
                            `;
                            
                            jobsTableBody.appendChild(row);
                        });
                        
                        // Add event listeners to view buttons
                        document.querySelectorAll('.view-job-btn').forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                const jobId = e.currentTarget.getAttribute('data-job-id');
                                viewJob(jobId);
                            });
                        });
                    }
                } catch (error) {
                    console.error('Error loading jobs:', error);
                }
            }
            
            // View a specific job
            async function viewJob(jobId) {
                try {
                    const response = await fetch(`/job/${jobId}`);
                    const jobData = await response.json();
                    
                    // Setup the job status card
                    currentJobId = jobId;
                    jobIdDisplay.textContent = jobId.substring(0, 8) + '...';
                    jobStatusCard.classList.remove('d-none');
                    
                    // Update display
                    updateJobStatusDisplay(jobData);
                    
                    // If job is still running, start polling
                    if (jobData.status === 'queued' || jobData.status === 'processing') {
                        startPolling(jobId);
                    } else {
                        // For completed/failed jobs, just show the results
                        showResults(jobData);
                    }
                    
                    // Scroll to the job status card
                    jobStatusCard.scrollIntoView({ behavior: 'smooth' });
                    
                } catch (error) {
                    console.error('Error viewing job:', error);
                }
            }
            
            // Process form submission
            processForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                // Show spinner and disable button
                processSpinner.classList.remove('d-none');
                processButton.disabled = true;
                
                // Hide result cards
                resultCard.classList.add('d-none');
                jobStatusCard.classList.add('d-none');
                
                // Get form values
                const enableChunking = enableChunkingSwitch.checked;
                const chunkSize = document.getElementById('chunk-size').value;
                const minSize = document.getElementById('min-size').value;
                const overlap = document.getElementById('overlap').value;
                const enableEnrichment = document.getElementById('enable-enrichment').checked;
                
                // Create form data
                const formData = new FormData();
                formData.append('enable_chunking', enableChunking);
                formData.append('chunk_size', chunkSize);
                formData.append('min_size', minSize);
                formData.append('overlap', overlap);
                formData.append('enhance_chunks', enableEnrichment);
                
                try {
                    // Send request to start processing
                    const response = await fetch('/process-documents', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'error') {
                        // Show error
                        resultCard.classList.remove('d-none');
                        resultContent.innerHTML = `<div class="alert alert-danger">${data.message}</div>`;
                    } else {
                        // Get the job ID and start tracking progress
                        const jobId = data.job_id;
                        
                        // Setup the job status card
                        currentJobId = jobId;
                        jobIdDisplay.textContent = jobId.substring(0, 8) + '...';
                        jobStatusCard.classList.remove('d-none');
                        
                        // Start polling for updates
                        startPolling(jobId);
                        
                        // Load all jobs
                        loadAllJobs();
                    }
                } catch (error) {
                    // Show error
                    resultCard.classList.remove('d-none');
                    resultContent.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
                } finally {
                    // Hide spinner and enable button
                    processSpinner.classList.add('d-none');
                    processButton.disabled = false;
                }
            });
            
            // Polling control event listeners
            stopPollingBtn.addEventListener('click', stopPolling);
            resumePollingBtn.addEventListener('click', resumePolling);
            refreshJobsBtn.addEventListener('click', loadAllJobs);
            
            // Load all jobs on page load
            loadAllJobs();
        });
    </script>
    <style>
        .job-stats .stat-item {
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .job-stats .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        .job-stats .stat-label {
            font-size: 14px;
            color: #666;
        }
        .job-id-badge {
            font-family: monospace;
        }
    </style>
</body>
</html>